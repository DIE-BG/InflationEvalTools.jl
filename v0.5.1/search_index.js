var documenterSearchIndex = {"docs":
[{"location":"#InflationEvalTools","page":"Home","title":"InflationEvalTools","text":"Types, functions, and simulation utilities for the evaluation of inflation measures.","category":"section"},{"location":"#Defaults","page":"Home","title":"Defaults","text":"","category":"section"},{"location":"#Resampling-Methods","page":"Home","title":"Resampling Methods","text":"Resampling functions for CPI bases and related utilities.","category":"section"},{"location":"#B-TIMA-Extension","page":"Home","title":"B-TIMA Extension","text":"The B-TIMA extension procedure uses the following functions: ","category":"section"},{"location":"#Trend-Functions","page":"Home","title":"Trend Functions","text":"Functions for trend application and modeling.","category":"section"},{"location":"#Parametric-Base-Methods","page":"Home","title":"Parametric Base Methods","text":"Methods to obtain bases of population monthly price changes.","category":"section"},{"location":"#Simulation-Configuration","page":"Home","title":"Simulation Configuration","text":"Types and utilities for simulation and evaluation period configuration.","category":"section"},{"location":"#Trajectory-Generation","page":"Home","title":"Trajectory Generation","text":"Functions for generating inflation trajectories.","category":"section"},{"location":"#Evaluation-and-Metrics","page":"Home","title":"Evaluation & Metrics","text":"Functions for simulation evaluation and metrics.","category":"section"},{"location":"#Combination-Methods","page":"Home","title":"Combination Methods","text":"Optimal combination of estimators and related utilities.","category":"section"},{"location":"#InflationEvalTools.InflationEvalTools","page":"Home","title":"InflationEvalTools.InflationEvalTools","text":"InflationEvalTools\n\nTypes, functions, and other simulation utilities for the evaluation of inflation measures.\n\n\n\n\n\n","category":"module"},{"location":"#InflationEvalTools.DEFAULT_SEED","page":"Home","title":"InflationEvalTools.DEFAULT_SEED","text":"DEFAULT_SEED\n\nDefault seed used for the simulation process and the reproducibility of the results.\n\n\n\n\n\n","category":"constant"},{"location":"#InflationEvalTools.LOCAL_RNG","page":"Home","title":"InflationEvalTools.LOCAL_RNG","text":"const LOCAL_RNG = StableRNG(0)\n\nThis constant is used to set the random number generator in each local process, using the StableRNG generator with initial seed zero. The seed will be altered in each iteration of the simulation process. This guarantees the reproducibility of the results per resampling realization by choosing the constant DEFAULT_SEED.\n\n\n\n\n\n","category":"constant"},{"location":"#InflationEvalTools.DEFAULT_RESAMPLE_FN","page":"Home","title":"InflationEvalTools.DEFAULT_RESAMPLE_FN","text":"DEFAULT_RESAMPLE_FN\n\nDefines the default resampling function to use in the simulation exercise.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.DEFAULT_TREND_FN","page":"Home","title":"InflationEvalTools.DEFAULT_TREND_FN","text":"DEFAULT_TREND_FN\n\nDefines the default trend function to use in the simulation exercise.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.ResampleFunction","page":"Home","title":"InflationEvalTools.ResampleFunction","text":"abstract type ResampleFunction <: Function end\n\nAbstract type for resampling functions. Each function must at least extend the method\n\nresamplefn(vmat::AbstractMatrix, rng)::Matrix \n\nto resample a CountryStructure with the functions defined above.\n\nOptionally, if you want to modify the specific behavior of each resampling function, you must extend the following methods:\n\nfunction (resamplefn::ResampleFunction)(cs::CountryStructure, rng = Random.GLOBAL_RNG)\nfunction (resamplefn::ResampleFunction)(base::VarCPIBase, rng = Random.GLOBAL_RNG)\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.ResampleScrambleVarMonths","page":"Home","title":"InflationEvalTools.ResampleScrambleVarMonths","text":"ResampleScrambleVarMonths <: ResampleFunction\n\nDefines a resampling function to resample the time series by the same months of occurrence. The sampling is performed independently for each time series in the columns of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.ResampleScrambleTrended","page":"Home","title":"InflationEvalTools.ResampleScrambleTrended","text":"ResampleScrambleTrended <: ResampleFunction\n\nResampling function that uses IID bootstrap weighted by months of occurrence to recreate the trend of the data.\n\nFields\n\np::Float64: Probability parameter controlling the trend weighting in the resampling process.\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.ResampleTrended","page":"Home","title":"InflationEvalTools.ResampleTrended","text":"ResampleTrended{T<:AbstractFloat} <: ResampleFunction\n\nResampling function that uses IID bootstrap weighted by months of occurrence with individual parameters for each CPI base, to recreate the trend of the data.\n\nFields\n\np::Vector{T}: Individual probability parameters for each CPI base, controlling the trend weighting in the resampling process.\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.ResampleExtendedSVM","page":"Home","title":"InflationEvalTools.ResampleExtendedSVM","text":"ResampleExtendedSVM <: ResampleFunction\n\nDefine a resampling function to resample the time series for the same months of occurrence. Sampling is performed independently for each time series in the columns of the matrix of monthly price changes. \n\nExample\n\nIn this example, GTDATA23 is a CountryStructure and contains three VarCPIBase objects. For each CPI dataset, the resampling is performed with the same length as the vector used as a parameter in ResampleExtendedSVM().\n\nresamplefn = ResampleExtendedSVM([150, 180, 50])\nresamplefn(GTDATA23)\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.ResampleIdentity","page":"Home","title":"InflationEvalTools.ResampleIdentity","text":"ResampleIdentity()\n\nAn identity resampling function type. Calling an instance of ResampleIdentity on a VarCPIBase or CountryStructure returns the exact same object (no resampling performed). Use this when you want to disable resampling and work with the original observed datasets.\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.get_param_function","page":"Home","title":"InflationEvalTools.get_param_function","text":"get_param_function(::ResampleFunction)\n\nEach resampling function must implement a function to obtain a CountryStructure with VarCPIBase objects that contain the average (or parametric) month-to-month variations that allow constructing the parametric inflation trajectory according to the resampling method given in ResampleFunction.\n\nThis function returns the function to obtain parametric data.\n\nExample\n\n# Obtain the resampling function\nresamplefn = ResampleSBB(36)\n...\n\n# Obtain its function to get the parametric data\nparamdatafn = get_param_function(resamplefn)\n# Obtain CountryStructure of parametric data\nparamdata = paramdatafn(gtdata)\n\n\n\n\n\nget_param_function(resamplefn::ResampleIdentity)\n\nReturn a function that, when called with a VarCPIBase, returns the same VarCPIBase object (the actual data). This matches the get_param_function contract used by other resamplers, with the exception of returning actual data.\n\n\n\n\n\nget_param_function(resamplefn::ResampleMixture)\n\nReturn a function that, when called with a CountryStructure, applies each resampling function's parameter function to its corresponding base. The returned function creates a new CountryStructure with the parameter data from each base.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.method_name","page":"Home","title":"InflationEvalTools.method_name","text":"method_name(resamplefn::ResampleFunction)\n\nFunction to obtain the name of the resampling method.\n\n\n\n\n\nmethod_name(resamplefn::TrendFunction)\n\nFunction to obtain the name of the trend function.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.method_tag","page":"Home","title":"InflationEvalTools.method_tag","text":"method_tag(resamplefn::ResampleFunction)\n\nFunction to obtain a tag for the resampling method.\n\n\n\n\n\nmethod_tag(trendfn::TrendFunction)\n\nFunction to obtain a tag for the trend function.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.CPIVarietyMatchDistribution","page":"Home","title":"InflationEvalTools.CPIVarietyMatchDistribution","text":"CPIVarietyMatchDistribution(\n    prior_dist, \n    actual_dist, \n    month; \n    weighing_function_type=:synthetic, \n    prior_variety_id=nothing, \n    prior_variety_name=nothing, \n    actual_variety_id=nothing, \n    actual_variety_name=nothing\n)\n\nCreate a synthetic empirical distribution that matches an item (variety) between two adjacent CPI bases. The object stores the concatenated distribution of monthly price changes, sampling weights (according to the selected reweighing strategy), and metadata such as the month and optional ids/names.\n\nArguments\n\nprior_dist, actual_dist: vectors of monthly price changes for the   prior and actual variety samples.\nmonth: integer month (1..12) the observations correspond to.\n\nKeyword arguments\n\nweighing_function_type: :synthetic (default), :prior, :actual, or a   custom function accepting (prior_dist, actual_dist) and returning a   scalar weighting function w(x) used to construct sampling weights.\noptional prior_variety_id, prior_variety_name, actual_variety_id,   actual_variety_name to store identifying metadata.\n\nExample\n\n# Suppose v_10 and v_23 are two vectors of monthly changes for the same item\n# observed in two CPI bases and m is the month (1..12).\nvar = CPIVarietyMatchDistribution(v_10, v_23, m)\nprintln(var)                     # short display\nmean(var)                        # returns the computed expected value\nstd(var)                         # returns the weighted std dev\nStatsBase.sample(var)            # draw one sample (uses stored weights)\nStatsBase.sample(var, 10)        # draw 10 samples\n\n# You can explicitly request prior-only or actual-only sampling:\nvar_prior = CPIVarietyMatchDistribution(v_10, v_23, m, :prior)\nvar_actual = CPIVarietyMatchDistribution(v_10, v_23, m, :actual)\n\nSee also: synthetic_reweighing, prior_reweighing, actual_reweighing.\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.ResampleSynthetic","page":"Home","title":"InflationEvalTools.ResampleSynthetic","text":"ResampleSynthetic(\n    base::VarCPIBase, \n    matching_structure::Matrix{CPIVarietyMatchDistribution}, \n    numperiods = periods(base)\n)\n\nCreate a resampling function that implements the B-TIMA Extension Methodology for generating synthetic samples from matched CPI items between two adjacent CPI bases. Importantly, ResampleSynthetic is to be used only for VarCPIBase objects because the required matching structure is specific to the VarCPIBase.\n\nArguments\n\nbase: A VarCPIBase object that provides reference dimensions and dates\nmatching_structure: A 2D array of CPIVarietyMatchDistribution objects with shape (periods, items) containing the matching distributions for each item and month\nnumperiods: Optional number of periods to generate in the resampled series (defaults to the number of periods in base)\n\nExample\n\n# Create matching distributions for each item and month\nmatching_array = Array{CPIVarietyMatchDistribution}(undef, 12, nitems)\nfor j in 1:nitems, m in 1:12\n    v_prior, v_actual = get_obs_month(prior_codes[j], actual_codes[j], m)\n    # Use synthetic reweighing for items 1-99\n    # prior-only for items 100-349\n    # actual-only for remaining items\n    weighing = j < 100 ? :synthetic : (j < 350 ? :prior : :actual)\n    matching_array[m,j] = CPIVarietyMatchDistribution(v_prior, v_actual, m, weighing)\nend\n\n# Create resampler with 5 years of data\nsynth_resampler = ResampleSynthetic(base, matching_array, 12*5)\n\n# Generate a synthetic sample\nvarbase_sample = synth_resampler(base)\n\n# Get the population mean parameters\npopulation_fn = get_param_function(synth_resampler)\npopulation_base = population_fn(base)\n\nSee also: CPIVarietyMatchDistribution, synthetic_reweighing, prior_reweighing, actual_reweighing\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.synthetic_reweighing","page":"Home","title":"InflationEvalTools.synthetic_reweighing","text":"synthetic_reweighing(prior_dist, actual_dist; a = 0.35, eps = 0.0001)\n\nCreate a reweighing function that assigns weights based on how close each value is to  the mean of the actual distribution, using a normal density function. This is the default reweighing strategy used in CPIVarietyMatchDistribution.\n\nArguments\n\nprior_dist: Vector of monthly price changes from the prior CPI base\nactual_dist: Vector of monthly price changes from the actual CPI base\na: Scaling factor for the standard deviation (default: 0.35)\neps: Small value added to avoid zero variance (default: 0.0001)\n\nReturns a function w(x) that computes weights proportional to the normal density  of the absolute difference between x and the actual mean.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.prior_reweighing","page":"Home","title":"InflationEvalTools.prior_reweighing","text":"prior_reweighing(prior_dist, actual_dist)\n\nCreate a reweighing function that only samples from the prior distribution, assigning unit weights to values from the prior distribution and zero weights to values from the actual distribution.\n\nArguments\n\nprior_dist: Vector of monthly price changes from the prior CPI base\nactual_dist: Vector of monthly price changes from the actual CPI base (unused)\n\nReturns a function w(x) that assigns 1 if x is in the prior distribution and 0 otherwise. Used when :prior is specified as the weighingfunctiontype in CPIVarietyMatchDistribution.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.actual_reweighing","page":"Home","title":"InflationEvalTools.actual_reweighing","text":"actual_reweighing(prior_dist, actual_dist)\n\nCreate a reweighing function that only samples from the actual distribution, assigning unit weights to values from the actual distribution and zero weights to values from the prior distribution.\n\nArguments\n\nprior_dist: Vector of monthly price changes from the prior CPI base (unused)\nactual_dist: Vector of monthly price changes from the actual CPI base\n\nReturns a function w(x) that assigns 1 if x is in the actual distribution and 0 otherwise. Used when :actual is specified as the weighingfunctiontype in CPIVarietyMatchDistribution.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.ResampleMixture","page":"Home","title":"InflationEvalTools.ResampleMixture","text":"ResampleMixture(resampling_functions::Vector{<:ResampleFunction})\n\nCreates a resampling function that applies different resampling methods to each VarCPIBase object in a CountryStructure. The number of resampling functions provided must match the number of VarCPIBase objects in the CountryStructure.\n\nArguments\n\nresampling_functions: A vector of ResampleFunction objects, where each element corresponds to the resampling function to be applied to the VarCPIBase object at the same index in a CountryStructure.\n\nExample\n\n# Create different resampling functions for each base\nresample_identity = ResampleIdentity()\nresample_synthetic = ResampleSynthetic(base, matching_array)\n\n# Create a mixed resampler that applies each function to its corresponding base\nmixed_resampler = ResampleMixture([resample_identity, resample_synthetic])\n\n# Apply the mixed resampling to a CountryStructure with two bases\nresampled_cs = mixed_resampler(cs)\n\n# Get the population parameters using each sampler's param function\npopulation_fn = get_param_function(mixed_resampler)\npopulation_cs = population_fn(cs)\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.RWTREND","page":"Home","title":"InflationEvalTools.RWTREND","text":"RWTREND\n\nPrecalibrated random walk trajectory for 292 periods.\n\n\n\n\n\n","category":"constant"},{"location":"#InflationEvalTools.TrendFunction","page":"Home","title":"InflationEvalTools.TrendFunction","text":"abstract type TrendFunction <: Function end\n\nAbstract type to handle trend functions.\n\nUsage\n\nfunction (trendfn::TrendFunction)(cs::CountryStructure)\n\nApplies the trend function to a CountryStructure and returns a new CountryStructure.\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.ArrayTrendFunction","page":"Home","title":"InflationEvalTools.ArrayTrendFunction","text":"abstract type ArrayTrendFunction <: TrendFunction end\n\nType for trend function that stores the vector of values to apply to the month-to-month variations.\n\nUsage\n\nfunction (trendfn::ArrayTrendFunction)(base::VarCPIBase{T}, range::UnitRange) where T\n\nSpecifies how to apply the trend function to a VarCPIBase with the index range range.\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.TrendRandomWalk","page":"Home","title":"InflationEvalTools.TrendRandomWalk","text":"TrendRandomWalk{T} <: ArrayTrendFunction\n\nType to represent a random walk trend function. Uses the precalibrated random walk vector in RWTREND.\n\nExample:\n\n# Create the random walk trend function\ntrendfn = TrendRandomWalk()\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.get_ranges","page":"Home","title":"InflationEvalTools.get_ranges","text":"get_ranges(cs::CountryStructure)\n\nHelper function to obtain a tuple of index ranges for slicing the trend vectors.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.TrendAnalytical","page":"Home","title":"InflationEvalTools.TrendAnalytical","text":"TrendAnalytical{T} <: ArrayTrendFunction\n\nType to represent a trend function defined by an anonymous function. Receives the data from a CountryStructure or a range of indices to precompute the trend vector using an anonymous function.\n\nExamples:\n\nTo create a trend function from an anonymous function: \n\ntrendfn = TrendAnalytical(param_data, t -> 1 + sin(2π*t/12), \"Sinusoidal trend\")\n\nor: \n\ntrendfn = TrendAnalytical(1:periods(param_data), t -> 1 + sin(2π*t/12), \"Sinusoidal trend\")\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.TrendExponential","page":"Home","title":"InflationEvalTools.TrendExponential","text":"TrendExponential{T} <: ArrayTrendFunction\n\nConcrete type to represent an exponential growth trend function. \n\nConstructors\n\nfunction TrendExponential(cs::CountryStructure, rate::Real = 0.02f0)\nfunction TrendExponential(range::UnitRange, rate::Real = 0.02f0)\n\nExamples:\n\n# Create a trend function with 2% annual exponential growth\ntrendfn = TrendExponential(gtdata, 0.02)\n\nUsage\n\nfunction (trendfn::TrendExponential)(cs::CountryStructure)\n\nApplication of TrendExponential trend to the VarCPIBase objects that make up the CountryStructure. \n\ntrendfn = TrendExponential(gtdata, 0.02) \ntrended_cs = trendfn(gtdata) \n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.TrendIdentity","page":"Home","title":"InflationEvalTools.TrendIdentity","text":"TrendIdentity <: TrendFunction\n\nConcrete type to represent a neutral trend function. That is, this trend function leaves the data unchanged. \n\nExamples:\n\n# Create an identity trend function. \ntrendfn = TrendIdentity()\n\nUsage\n\nfunction (trendfn::TrendIdentity)(cs::CountryStructure)\n\nApplication of TrendIdentity trend to VarCPIBase. This method is redefined to leave the VarCPIBase unchanged. \n\ntrendfn = TrendIdentity() \ntrended_cs = trendfn(gtdata) \n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.TrendDynamicRW","page":"Home","title":"InflationEvalTools.TrendDynamicRW","text":"TrendDynamicRW{T, F<:Function} <: ArrayTrendFunction\n\nType to represent a dynamic random walk (or AR(1)) trend function. Generates an AR(1) process that satisfies a validation function.\n\nFields\n\ntrend::Vector{T}: The generated trend vector.\nL::Int: Length of the process.\nphi::T: Autocorrelation parameter.\nsigma::T: Standard deviation of shocks.\nf::F: Validation function to select realizations of the process.\n\nConstructor\n\nTrendDynamicRW(L::Int, phi::Real, sigma::Real, f::Function; rng=Random.GLOBAL_RNG)\n\nCreates a TrendDynamicRW object by generating an AR(1) process with parameters L, phi, and sigma until the validation function f returns true.\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.zeromean_validation","page":"Home","title":"InflationEvalTools.zeromean_validation","text":"zeromean_validation(y; atol = 0.1)\n\nValidation function that returns true if the mean of the vector y is approximately zero, within the absolute tolerance atol. Vector y is typically the generated AR(1) process before exponentiation.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.create_TrendDynamicRW_array","page":"Home","title":"InflationEvalTools.create_TrendDynamicRW_array","text":"create_TrendDynamicRW_array(L::Int = 360, phi::Real = 1.0f0, sigma::Real = 0.05f0, f::Function = zeromean_validation, nfolds::Int = 10; rng = Random.GLOBAL_RNG)\n\nCreate a vector of TrendDynamicRW objects with the specified parameters.\n\nArguments\n\nL::Int: Length of the trend process (default 360).\nphi::Real: Autoregressive coefficient (default 1.0).\nsigma::Real: Standard deviation of the shocks (default 0.05).\nf::Function: Validation function (default zeromean_validation).\nnfolds::Int: Number of trend functions to generate (default 10).\nrng: Random number generator (default Random.GLOBAL_RNG).\n\nReturns a Vector{TrendDynamicRW}.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.AbstractInflationParameter","page":"Home","title":"InflationEvalTools.AbstractInflationParameter","text":"Abstract type to represent inflation parameters\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.param_scramblevar_fn","page":"Home","title":"InflationEvalTools.param_scramblevar_fn","text":"param_scramblevar_fn(base::VarCPIBase)\n\nObtains the matrix of population monthly price changes for the B-TIMA bootstrap resampling methodology by the same calendar months. Returns a VarCPIBase type base with the average month-to-month variations of the same months of occurrence (also called population monthly price changes).\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.InflationParameter","page":"Home","title":"InflationEvalTools.InflationParameter","text":"Concrete type to represent an inflation parameter computed with the inflation function inflfn, the resampling method resamplefn, and trend function trendfn.\n\nSee also: ParamTotalCPIRebase, ParamTotalCPI, ParamWeightedMean\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.ParamTotalCPIRebase","page":"Home","title":"InflationEvalTools.ParamTotalCPIRebase","text":"ParamTotalCPIRebase()\n\nHelper function to obtain the configuration of the inflation parameter given by the synthetic base change CPI inflation function, and the default resampling method and trend function.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.ParamTotalCPI","page":"Home","title":"InflationEvalTools.ParamTotalCPI","text":"ParamTotalCPI()\n\nHelper function to obtain the configuration of the inflation parameter given by the CPI inflation function, and the default resampling method and trend function.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.ParamWeightedMean","page":"Home","title":"InflationEvalTools.ParamWeightedMean","text":"ParamWeightedMean()\n\nHelper function to obtain the configuration of the inflation parameter given by the interannual weighted mean and the default resampling method.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.ParamTotalCPILegacyRebase","page":"Home","title":"InflationEvalTools.ParamTotalCPILegacyRebase","text":"ParamTotalCPILegacyRebase()\n\nHelper function to obtain the configuration of the inflation parameter given by the synthetic base change CPI inflation function, and the default resampling method and trend function.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.AbstractConfig","page":"Home","title":"InflationEvalTools.AbstractConfig","text":"abstract type AbstractConfig{F <: InflationFunction, R <:ResampleFunction, T <:TrendFunction} end\n\nAbstractConfig is an abstract type to represent simulation variants that generally use an inflation function InflationFunction, a resampling function ResampleFunction, and a trend function TrendFunction. It contains the general scheme of the simulation.\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.SimConfig","page":"Home","title":"InflationEvalTools.SimConfig","text":"SimConfig{F, R, T} <:AbstractConfig{F, R, T}\n\nConcrete type that contains a base configuration to generate simulations using all data as the training set. Receives an inflation function InflationFunction, a resampling function ResampleFunction, a trend function TrendFunction, an evaluation inflation function [paramfn], and the desired number of simulations [nsim].\n\nExample\n\nConsidering the following instances of inflation, resampling, trend, and evaluation inflation functions:\n\njulia> percEq = InflationPercentileEq(80);\n\njulia> resamplefn = ResampleSBB(36);\n\njulia> trendfn = TrendRandomWalk();\n\njulia> paramfn = InflationWeightedMean();\n\nWe generate a SimConfig configuration with 1000 simulations, with default evaluation periods:\n\nCompletePeriod(), \nGT_EVAL_B00, \nGT_EVAL_T0010 and  \nGT_EVAL_B10\n\njulia> config = SimConfig(percEq, resamplefn, trendfn, paramfn, 1000, Date(2019,12))\nSimConfig{InflationPercentileEq, ResampleSBB, TrendRandomWalk{Float32}}\n|─> Inflation function            : Percentil equiponderado 80.0\n|─> Resampling function           : Block bootstrap estacionario con bloque esperado 36\n|─> Trend function                : Tendencia de caminata aleatoria\n|─> Parametric inflation method   : Media ponderada interanual\n|─> Number of simulations         : 1000\n|─> End of training set           : Dec-19\n|─> Evaluation periods            : Complete period, gt_b00:Dec-01-Dec-10, gt_t0010:Jan-11-Nov-11 y gt_b10:Dec-11-Dec-20\n\nTo generate a configuration with specific periods, you can provide the collection of periods of interest:\n\njulia> config2 = SimConfig(percEq, resamplefn, trendfn, paramfn, 1000, Date(2019,12),\n       (CompletePeriod(), EvalPeriod(Date(2008,1), Date(2009,12), \"fincrisis\")))\nSimConfig{InflationPercentileEq, ResampleSBB, TrendRandomWalk{Float32}}\n|─> Inflation function            : Percentil equiponderado 80.0\n|─> Resampling function           : Block bootstrap estacionario con bloque esperado 36\n|─> Trend function                : Tendencia de caminata aleatoria\n|─> Parametric inflation method   : Media ponderada interanual\n|─> Number of simulations         : 1000\n|─> End of training set           : Dec-19\n|─> Evaluation periods            : Complete period y fincrisis:Jan-08-Dec-09\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.SimDynamicConfig","page":"Home","title":"InflationEvalTools.SimDynamicConfig","text":"SimDynamicConfig{F, R, T}\n\nConfiguration type for simulations using the dynamic random walk trend (TrendDynamicRW). This configuration is similar to SimConfig but does not include a trendfn field, as it is implicitly designed for the dynamic trend.\n\nIt contains:\n\ninflfn: Inflation function\nresamplefn: Resampling function\ntrendfns: Vector of trend functions.\nparamfn: Parametric inflation function (for population trend)\nnsim: Number of simulations per fold\nnfolds: Number of folds (trend instantiations)\ntraindate: End date of training set\nevalperiod: Evaluation period\n\nExample\n\nconfig = SimDynamicConfig(inflfn, resamplefn, trend_functions, paramfn, 1000, 10, Date(2019,12), CompletePeriod())\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.AbstractEvalPeriod","page":"Home","title":"InflationEvalTools.AbstractEvalPeriod","text":"abstract type AbstractEvalPeriod\n\nAbstract type to represent types of evaluation periods.\n\nSee also: EvalPeriod, CompletePeriod.\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.CompletePeriod","page":"Home","title":"InflationEvalTools.CompletePeriod","text":"CompletePeriod <: AbstractEvalPeriod\n\nType to represent the complete evaluation period, corresponding to the inflation periods of the data CountryStructure. The default tag for the complete period is empty (\"\"), so that the evaluation metrics in the results generated in compute_lowlevel_sim do not have a prefix, as it is the main evaluation period. This period can be provided to a SimConfig configuration to evaluate over the entire range of simulated inflation dates.\n\nExample\n\nWe create an instance of this type to represent the evaluation over the complete period of the inflation trajectories generated in the simulations.\n\njulia> comp = CompletePeriod()\nComplete period\n\nSee also: EvalPeriod, GT_EVAL_B00, GT_EVAL_B10, GT_EVAL_T0010\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.EvalPeriod","page":"Home","title":"InflationEvalTools.EvalPeriod","text":"EvalPeriod <: AbstractEvalPeriod\n\nType to represent an evaluation period given by the dates startdate and finaldate. A label must be included in the tag field to attach to the results generated in compute_lowlevel_sim. This period can be provided to a SimConfig configuration to evaluate over a specific date range.\n\nExample\n\nWe create an evaluation period called b2010 when generating the results.\n\njulia> b2010 = EvalPeriod(Date(2011,1), Date(2019,12), \"b2010\")\nb2010:Jan-11-Dec-19\n\nSee also: GT_EVAL_B00, GT_EVAL_B10, GT_EVAL_T0010\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.PeriodVector","page":"Home","title":"InflationEvalTools.PeriodVector","text":"PeriodVector <: AbstractEvalPeriod\n\nType to represent a collection of evaluation periods, each given by a tuple of start and end dates. The tag field is used to label the set of periods for identification in results.\n\nExample\n\nCreate a PeriodVector with two evaluation periods and a tag:\n\njulia> pv = PeriodVector([(Date(2011,1), Date(2012,12)), (Date(2015,1), Date(2016,12))], \"multi\")\nPeriodVector([(2011-01-01, 2012-12-31), (2015-01-01, 2016-12-31)], \"multi\")\n\nSee also: EvalPeriod, eval_periods\n\n\n\n\n\n","category":"type"},{"location":"#InflationEvalTools.eval_periods","page":"Home","title":"InflationEvalTools.eval_periods","text":"eval_periods(cs::CountryStructure, period::EvalPeriod) -> BitVector\neval_periods(cs::CountryStructure, ::CompletePeriod) -> UnitRange\n\nReturns a mask or a range of indices of the periods included in EvalPeriod or CompletePeriod to apply slicing to the inflation trajectories and the parameter before obtaining the evaluation metrics.\n\nSee also: EvalPeriod, CompletePeriod, period_tag.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.period_tag","page":"Home","title":"InflationEvalTools.period_tag","text":"period_tag(period::EvalPeriod) -> String\nperiod_tag(::CompletePeriod) -> String\n\nFunction to obtain the label associated with the evaluation period. The complete evaluation period has an empty label (\"\").\n\nSee also: EvalPeriod, CompletePeriod, eval_periods.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.GT_EVAL_B00","page":"Home","title":"InflationEvalTools.GT_EVAL_B00","text":"const GT_EVAL_B00 = EvalPeriod(Date(2001, 12), Date(2010, 12), \"gt_b00\")\n\nDefault period for evaluation in the decade of the 2000s, including the year 2010.\n\n\n\n\n\n","category":"constant"},{"location":"#InflationEvalTools.GT_EVAL_B10","page":"Home","title":"InflationEvalTools.GT_EVAL_B10","text":"const GT_EVAL_B10 = EvalPeriod(Date(2011, 12), Date(2021, 12), \"gt_b10\")\n\nDefault period for evaluation in the decade of the 2010s, including the year 2021.\n\n\n\n\n\n","category":"constant"},{"location":"#InflationEvalTools.GT_EVAL_T0010","page":"Home","title":"InflationEvalTools.GT_EVAL_T0010","text":"const GT_EVAL_T0010 = EvalPeriod(Date(2011, 1), Date(2011, 11), \"gt_t0010\")\n\nDefault period for evaluation in the transition from the 2000s to the 2010s.\n\n\n\n\n\n","category":"constant"},{"location":"#InflationEvalTools.gentrajinfl","page":"Home","title":"InflationEvalTools.gentrajinfl","text":"function gentrajinfl(\n        inflfn::F, resamplefn::R, trendfn::T,\n        csdata::CountryStructure;\n        numreplications = 100,\n        rndseed = DEFAULT_SEED,\n        showprogress = true\n    ) where {F <: InflationFunction, R <: ResampleFunction, T <: TrendFunction}\n\nComputes numreplications inflation trajectories using the inflation function inflfn::InflationFunction, the resampling function resamplefn::TrendFunction and the specified trend function trendfn::TrendFunction. The data in the given CountryStructure csdata are used.\n\nUnlike the pargentrajinfl function, this function does not perform the computation in a distributed manner.\n\nTo achieve reproducibility between different runs of the function, and thus generate inflation trajectories with different methodologies using the same resamplings, the generation seed is set according to the iteration number in the simulation. To control the start of the trajectory generation, the rndseed offset parameter is used, whose default value is the seed DEFAULT_SEED.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.pargentrajinfl","page":"Home","title":"InflationEvalTools.pargentrajinfl","text":"pargentrajinfl(inflfn::F, resamplefn::R, trendfn::T, csdata::CountryStructure; \n    numreplications = 100, \n    rndseed = DEFAULT_SEED, \n    showprogress = true)\n\nComputes numreplications inflation trajectories using the inflation function inflfn::InflationFunction, the resampling function resamplefn::ResampleFunction and the specified trend function trendfn::TrendFunction. The data in the given CountryStructure csdata are used.\n\nUnlike the gentrajinfl function, this function implements distributed computation in processes using @distributed. This requires that the package has been loaded in all compute processes. For example:\n\nusing Distributed\naddprocs(4, exeflags=\"--project\")\n@everywhere using InflationEvalTools\n\nTo achieve reproducibility between different runs of the function, and thus generate inflation trajectories with different methodologies using the same resamplings, the generation seed is set according to the iteration number in the simulation. To control the start of the trajectory generation, the rndseed offset parameter is used, whose default value is the seed DEFAULT_SEED.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.compute_lowlevel_sim","page":"Home","title":"InflationEvalTools.compute_lowlevel_sim","text":"compute_lowlevel_sim(\n    data::CountryStructure, config::SimConfig;\n    rndseed = DEFAULT_SEED,\n    shortmetrics = false,\n    showprogress = false,\n    verbose = true,\n) -> (Dict, Array{<:AbstractFloat, 3})\n\nGenerate the parametric (population) trajectory, simulated inflation trajectories and evaluation metrics using a SimConfig.\n\nReturns a tuple (metrics, traj_infl) where metrics is a dictionary of evaluation measures and traj_infl is a 3‑D array with dimensions (T, 1, K) (T = time steps, K = number of bootstrap realizations).\n\nArguments\n\ndata::CountryStructure: country dataset container used for resampling and   trend estimation.\nconfig::SimConfig: configuration with inflfn, resamplefn, trendfn,   paramfn, nsim and evaluation periods.\n\nKeyword arguments\n\nrndseed: integer seed for the random generator (default = DEFAULT_SEED).\nshortmetrics: when true compute a reduced set of metrics (faster / lower   memory footprint). Default false.\nshowprogress: show progress bar during simulation generation (default   false).\nverbose: show information messages during the process (default true).\n\nSee also eval_metrics for details on the metric names stored in metrics.\n\n\n\n\n\ncompute_lowlevel_sim(\n    data::CountryStructure, config::SimDynamicConfig;\n    rndseed = DEFAULT_SEED,\n    shortmetrics = false,\n    showprogress = false,\n) -> (Dict, Array{<:AbstractFloat, 3})\n\nGenerate the parametric (population) trajectory, simulated inflation trajectories and evaluation metrics using a SimDynamicConfig.\n\nThis function iterates length(config.trendfns) times. In each fold, it uses  config.trendfns[i] to get the trend function for that fold. It generates config.nsim simulations per fold. The results are merged:\n\nMetrics are collected into vectors (one value per fold).\nTrajectories are concatenated along the third dimension (total simulations = nsim * nfolds).\n\nArguments\n\ndata::CountryStructure: country dataset container.\nconfig::SimDynamicConfig: configuration.\n\nKeyword arguments\n\nrndseed: integer seed for the random generator of the simulation trajectories (default = DEFAULT_SEED).\nshortmetrics: when true compute a reduced set of metrics.\nshowprogress: show progress bar.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.compute_assessment_sim","page":"Home","title":"InflationEvalTools.compute_assessment_sim","text":"compute_assessment_sim(\n    data::CountryStructure, config::SimConfig;\n    rndseed = DEFAULT_SEED,\n    savetrajectories = false,\n    shortmetrics = false,\n    showprogress = false,\n    verbose = true,\n) -> Dict\n\nRun the low‑level simulation (compute_lowlevel_sim), collect evaluation metrics and return a results dictionary that merges the SimConfig parameters with the computed metrics.\n\nReturns a dictionary results that always contains the metrics and config fields. If savetrajectories=true the returned dictionary includes the key :trajinfl containing the simulated trajectories array.\n\nKeyword arguments\n\nsavetrajectories: when true add trajectories to the results dictionary   (in the key :trajinfl). Default false.\nshortmetrics: compute a reduced metrics set when true (default false).\nshowprogress: show progress during trajectory generation (default   false).\nverbose: show information messages during the process (default true).\n\nExample\n\njulia> results = compute_assessment_sim(gtdata, config)\n\n\n\n\n\ncompute_assessment_sim(\n    data::CountryStructure, config::SimDynamicConfig;\n    rndseed = DEFAULT_SEED,\n    savetrajectories = false,\n    shortmetrics = false,\n    showprogress = false\n) -> Dict\n\nRun the low‑level simulation (compute_lowlevel_sim) for dynamic configuration.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.dict2config","page":"Home","title":"InflationEvalTools.dict2config","text":"dict2config(params::Dict)\n\nFunction to convert a parameter dictionary to SimConfig or SimDynamicConfig.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.run_assessment_batch","page":"Home","title":"InflationEvalTools.run_assessment_batch","text":"run_assessment_batch(\n    data::CountryStructure, dict_list_params, savepath::AbstractString;\n    rndseed = DEFAULT_SEED,\n    savetrajectories = false,\n    shortmetrics = false,\n    showprogress = true,\n    recompute = false,\n)\n\nGenerate a batch of simulation assessments from a list (or iterable) of parameter dictionaries. Each element in dict_list_params is converted to a SimConfig or a SimDynamicConfig with dict2config and evaluated with compute_assessment_sim. Results are saved to savepath using DrWatson.savename so they can later be read by collect_results. \n\nRecomputation of existing result files is skipped by default. To   force recomputation, set recompute=true.\n\nArguments\n\ndict_list_params: iterable of parameter dictionaries (usually created by   expanding vectors of parameter values).\nsavepath: directory where per‑run result files will be written.\n\nKeyword arguments\n\nsavetrajectories: save trajectories within each result file (default   false).\nshortmetrics: compute reduced metrics when true (default false).\nshowprogress: show progress indicator during generation (default   true).\nrecompute: when true, recompute existing result files even if they exist    on disk (default false).\n\nExample\n\nconfig_dict = Dict(\n    :inflfn => InflationPercentileWeighted.(50:80),\n    :resamplefn => resamplefn,\n    :trendfn => trendfn,\n    :paramfn => paramfn,\n    :traindate => Date(2019, 12),\n    :evalperiods => (CompletePeriod(),),\n    :nsim => 1000) |> dict_list\n\nrun_assessment_batch(gtdata_eval, config_dict, savepath)\n\nAfter the batch completes, use collect_results(savepath) to assemble a DataFrame with the stored metrics.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.eval_metrics","page":"Home","title":"InflationEvalTools.eval_metrics","text":"eval_metrics(tray_infl, tray_infl_pob; shortmetrics=false, prefix=\"\") -> Dict\n\nCompute evaluation metrics for inflation trajectories.\n\nThis function calculates various statistical metrics to evaluate the performance of simulated inflation trajectories (tray_infl) against a parametric population trajectory (tray_infl_pob).\n\nArguments\n\ntray_infl: Array of simulated inflation trajectories (3D array: periods x 1 x simulations).\ntray_infl_pob: Vector or 1-column matrix of the parametric population inflation trajectory.\nshortmetrics: Boolean. If true, returns a reduced dictionary with key metrics (MSE, RMSE, MAE, ME, AbsME, Huber, Correlation) and their standard errors. Default is true.\nprefix: String. Optional prefix for the keys in the output dictionary.\n\nReturns\n\nA dictionary containing the computed metrics.\n\nIf shortmetrics=true, the dictionary includes:\n\nmse, mse_std_error: Mean Squared Error and its standard error.\nrmse, rmse_std_error: Root Mean Squared Error and its standard error.\nmae, mae_std_error: Mean Absolute Error and its standard error.\nme, me_std_error: Mean Error (Bias) and its standard error.\nabsme, absme_std_error: Absolute Mean Error and its standard error.\nhuber, huber_std_error: Huber Loss and its standard error.\ncorr: Average correlation between simulations and population trajectory.\n\nIf shortmetrics=false, the dictionary additionally includes:\n\nstd_mse_dist: Standard deviation of the MSE distribution.\nstd_sqerr_dist: Standard deviation of the squared error distribution.\nmse_bias: Squared bias component of MSE decomposition.\nmse_var: Variance component of MSE decomposition.\nmse_cov: Covariance component of MSE decomposition.\nT: Number of periods.\nB: Number of simulations.\n\n\n\n\n\neval_metrics(tray_infl, tray_infl_pob; shortmetrics=false, prefix=\"\") -> Dict\n\nCompute evaluation metrics for inflation trajectories.\n\n# Arguments\n\ntray_infl: Array of simulated inflation trajectories (3D array: periods x 1 x simulations).\ntray_infl_pob: Array of the parametric population inflation trajectory (3D array: periods x 1 x batches).\nshortmetrics: Boolean. If true, returns a reduced dictionary with key metrics (MSE, RMSE, MAE, ME, AbsME, Huber, Correlation) and their standard errors. Default is true.\nprefix: String. Optional prefix for the keys in the output dictionary.\n\nReturns\n\nA dictionary containing the computed metrics.\n\nSee also: eval_metrics.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.combination_metrics","page":"Home","title":"InflationEvalTools.combination_metrics","text":"combination_metrics(tray_infl, tray_infl_param, w; kwargs...)\n\nMetrics for linear combination measures. The trajectories in tray_infl are combined with the weights w and the evaluation metrics are computed using the parametric trajectory tray_infl_param. \n\nOptional arguments (kwargs...) are passed to the function eval_metrics.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.eval_mse_online","page":"Home","title":"InflationEvalTools.eval_mse_online","text":"eval_mse_online(config::SimConfig, csdata::CountryStructure; \n    K = 1000, \n    rndseed = DEFAULT_SEED) -> mse\n\nFunction to obtain mean squared error evaluation using SimConfig evaluation configuration. The evaluation data must be provided in csdata, with which the comparison parametric trajectory is to be computed. Returns the MSE as a scalar.\n\nThis function can be used to optimize the parameters of different inflation measures and is more memory efficient than pargentrajinfl.\n\n\n\n\n\neval_mse_online(\n    inflfn::InflationFunction,\n    resamplefn::ResampleFunction, \n    trendfn::TrendFunction,\n    csdata::CountryStructure, \n    tray_infl_param::Vector{<:AbstractFloat}; \n    K = 1000, rndseed = DEFAULT_SEED) -> mse\n\nFunction to obtain mean squared error (MSE) evaluation using the specified configuration. The parametric trajectory tray_infl_param is required to avoid repeatedly computing it in this function. Returns the MSE as a scalar.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.eval_absme_online","page":"Home","title":"InflationEvalTools.eval_absme_online","text":"eval_absme_online(config::SimConfig, csdata::CountryStructure; \n    K = 1000, \n    rndseed = DEFAULT_SEED) -> absme\n\nFunction to obtain evaluation of the mean absolute error value using SimConfig evaluation configuration. The evaluation data must be provided in csdata, with which the comparison parametric trajectory is to be computed. Returns the absolute value metric as a scalar.\n\nThis function can be used to optimize the parameters of different inflation measures and is more memory efficient than pargentrajinfl.\n\n\n\n\n\neval_absme_online(\n    inflfn::InflationFunction,\n    resamplefn::ResampleFunction, \n    trendfn::TrendFunction,\n    csdata::CountryStructure, \n    tray_infl_param::Vector{<:AbstractFloat}; \n    K = 1000, rndseed = DEFAULT_SEED) -> absme\n\nFunction to obtain evaluation of the mean absolute error value (ABSME) using the specified configuration. The parametric trajectory tray_infl_param is required to avoid repeatedly computing it in this function. Returns the ABSME as a scalar.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.eval_corr_online","page":"Home","title":"InflationEvalTools.eval_corr_online","text":"eval_corr_online(config::SimConfig, csdata::CountryStructure;\n    K = 1000, \n    rndseed = DEFAULT_SEED) -> corr\n\nFunction to obtain mean correlation (corr) evaluation using SimConfig evaluation configuration. The evaluation data must be provided in csdata, with which the comparison parametric trajectory is to be computed. Returns the mean correlation (corr) as a scalar.\n\nThis function can be used to optimize the parameters of different inflation measures and is more memory efficient than pargentrajinfl.\n\n\n\n\n\neval_corr_online(\n    inflfn::InflationFunction,\n    resamplefn::ResampleFunction, \n    trendfn::TrendFunction,\n    csdata::CountryStructure, \n    tray_infl_param::Vector{<:AbstractFloat};\n    K = 1000, rndseed = DEFAULT_SEED) -> corr\n\nFunction to obtain mean correlation (corr) evaluation using the specified configuration. The parametric trajectory tray_infl_param is required to avoid repeatedly computing it in this function. Returns the mean correlation (corr) as a scalar.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools._merge_metrics","page":"Home","title":"InflationEvalTools._merge_metrics","text":"_merge_metrics(metrics_list::Vector{Dict})\n\nMerge a list of metric dictionaries into a single dictionary where values are vectors.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.combination_weights","page":"Home","title":"InflationEvalTools.combination_weights","text":"combination_weights(tray_infl, tray_infl_param) -> Vector{<:AbstractFloat}\n\nObtains the optimal weights from the analytical solution to the problem of minimizing the mean squared error of the linear combination of inflation estimators in tray_infl using the parametric inflation trajectory tray_infl_param. \n\nReturns a vector with the weights associated with each estimator in the columns of tray_infl.\n\nSee also: ridge_combination_weights, lasso_combination_weights, share_combination_weights, elastic_combination_weights. \n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.average_mats","page":"Home","title":"InflationEvalTools.average_mats","text":"average_mats(tray_infl, tray_infl_param) -> (Matrix{<:AbstractFloat}, Vector{<:AbstractFloat})\n\nObtains the matrices XᵀX and Xᵀπ for the mean squared error minimization problem. \n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.ridge_combination_weights","page":"Home","title":"InflationEvalTools.ridge_combination_weights","text":"ridge_combination_weights(tray_infl, tray_infl_param, lambda; \n    penalize_all = true) -> Vector{<:AbstractFloat}\n\nObtains optimal Ridge weights through the analytical solution to the problem of minimizing the mean squared error of the linear combination of inflation estimators in tray_infl using the parametric inflation trajectory tray_infl_param, regularized with the L2 norm of the weights, weighted by the parameter lambda.\n\nReturns a vector with the weights associated with each estimator in the columns of tray_infl.\n\nOptional parameters:  \n\npenalize_all (Bool): indicates whether to apply regularization to all weights. If false, regularization is applied from the second to the last component of the weights vector. Default is true.\n\nSee also: combination_weights, lasso_combination_weights, share_combination_weights, elastic_combination_weights.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.lasso_combination_weights","page":"Home","title":"InflationEvalTools.lasso_combination_weights","text":"lasso_combination_weights(tray_infl, tray_infl_param, lambda; \n    max_iterations::Int = 1000, \n    alpha = F(0.005), \n    tol = F(1e-4), \n    show_status = true, \n    return_cost = false, \n    penalize_all = true) -> Vector{<:AbstractFloat}\n\nObtiene ponderadores óptimos de LASSO a través de una aproximación iterativa al problema de minimización del error cuadrático medio de la combinación lineal de estimadores de inflación en tray_infl utilizando la trayectoria de inflación paramétrica tray_infl_param, regularizada con la norma L1 de los ponderadores, ponderada por el parámetro lambda.\n\nLos parámetros opcionales son: \n\nmax_iterations::Int = 1000: número máximo de iteraciones. \nalpha::AbstractFloat = 0.001: parámetro de aproximación o avance del algoritmo de gradiente próximo. \ntol::AbstractFloat = 1e-4: desviación absoluta de la función de costo. Si la función de costo varía en términos absolutos menos que tol de una iteración a otra, el algoritmo de gradiente se detiene. \nshow_status::Bool = true: mostrar estado del algoritmo iterativo.\nreturn_cost::Bool = false: indica si devuelve el vector de historia de la función de costo de entrenamiento. \npenalize_all::Bool = true: indica si aplicar la regularización a todos los ponderadores. Si es falso, se aplica la regularización a partir del segundo al último componente del vector de ponderaciones.\n\nDevuelve un vector con los ponderadores asociados a cada estimador en las columnas de tray_infl.\n\nVer también: combination_weights, ridge_combination_weights, share_combination_weights, elastic_combination_weights.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.share_combination_weights","page":"Home","title":"InflationEvalTools.share_combination_weights","text":"function share_combination_weights(tray_infl::AbstractArray{F, 3}, tray_infl_param; \n    restrict_all::Bool = true, \n    show_status::Bool = false) where F -> Vector{F}\n\nObtiene ponderadores no negativos, cuya suma es igual a 1. Estos ponderadores se pueden interpretar como participaciones en la combinación lineal. \n\nLos parámetros opcionales son: \n\nshow_status::Bool = false: mostrar estado del proceso de optimización con Ipopt y JuMP. \nrestrict_all::Bool = true: indica si aplicar la restricción de la suma de ponderadores a todas las entradas del vector de ponderaciones. Si es false, se aplica la restricción a partir de la segunda entrada. Esto es para que si el primer ponderador corresponde a un término constante, este no sea restringido. \n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.elastic_combination_weights","page":"Home","title":"InflationEvalTools.elastic_combination_weights","text":"elastic_combination_weights(tray_infl, tray_infl_param, lambda, gamma; \n    max_iterations::Int = 1000, \n    alpha = 0.001, \n    tol = 1e-4, \n    show_status = true, \n    return_cost = false, \n    penalize_all = true) -> Vector{<:AbstractFloat}\n\nObtiene ponderadores óptimos de Elastic Net a través de una aproximación iterativa al problema de minimización del error cuadrático medio de la combinación lineal de estimadores de inflación en tray_infl utilizando la trayectoria de inflación paramétrica tray_infl_param, regularizada con la norma L1 y L2 de los ponderadores, ponderada por el parámetro lambda. El porcentaje de regularización de la norma L1 se controla con el parámetro gamma.\n\nLos parámetros opcionales son: \n\nmax_iterations::Int = 1000: número máximo de iteraciones. \nalpha::AbstractFloat = 0.001: parámetro de aproximación o avance del algoritmo de gradiente próximo. \ntol::AbstractFloat = 1e-4: desviación absoluta de la función de costo. Si la función de costo varía en términos absolutos menos que tol de una iteración a otra, el algoritmo de gradiente se detiene. \nshow_status::Bool = true: mostrar estado del algoritmo iterativo.\nreturn_cost::Bool = false: indica si devuelve el vector de historia de la función de costo de entrenamiento. \npenalize_all::Bool = true: indica si aplicar la regularización a todos los ponderadores. Si es falso, se aplica la regularización a partir del segundo al último componente del vector de ponderaciones.\n\nDevuelve un vector con los ponderadores asociados a cada estimador en las columnas de tray_infl.\n\nVer también: combination_weights, ridge_combination_weights, share_combination_weights, lasso_combination_weights.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.metric_combination_weights","page":"Home","title":"InflationEvalTools.metric_combination_weights","text":"metric_combination_weights(tray_infl::AbstractArray{F, 3}, tray_infl_param; \n    metric::Symbol = :corr, \n    w_start = nothing, \n    x_abstol::AbstractFloat = 1f-2, \n    f_abstol::AbstractFloat = 1f-4, \n    max_iterations::Int = 1000) where F\n\nObtains optimal combination weights for the metric metric through an iterative approximation to the optimization problem of that metric for the linear combination of inflation estimators in tray_infl using the parametric inflation trajectory tray_infl_param.\n\nOptional parameters: \n\nmetric::Symbol = :corr: metric to optimize. If it is linear correlation, the metric is maximized. The rest of the metrics are minimized. See also eval_metrics.\nw_start = nothing: initial search weights. Typically, a vector of floating point values.\nx_abstol::AbstractFloat = 1f-2: maximum absolute deviation of the weights. \nf_abstol::AbstractFloat = 1f-4: maximum absolute deviation in the cost function.\nsum_abstol::AbstractFloat = 1f-2: maximum permissible absolute deviation in the sum of weights, with respect to one.\nmax_iterations::Int = 1000: maximum number of iterations. \npenalty::Function = w -> zero(F): penalty function applied to weights. \n\nReturns a vector with the weights associated with each estimator in the columns of tray_infl.\n\nSee also: combination_weights, ridge_combination_weights, share_combination_weights, elastic_combination_weights.\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.absme_combination_weights","page":"Home","title":"InflationEvalTools.absme_combination_weights","text":"absme_combination_weights(tray_infl::AbstractArray{F, 3}, tray_infl_param; \n    restrict_all::Bool = true, \n    show_status::Bool = false) where F -> Vector{F}\n\nObtains non-negative weights, whose sum is equal to 1, for the linear combination problem that minimizes the mean absolute error value. These weights can be interpreted as shares in the linear combination.\n\nOptional parameters: \n\nshow_status::Bool = false: show the status of the optimization process with Ipopt and JuMP. \nrestrict_all::Bool = true: indicates whether to apply the sum-to-one constraint to all entries of the weights vector. If false, the constraint is applied from the second entry. This is so that if the first weight corresponds to a constant term, it is not constrained. \n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.share_combination_weights_rmse","page":"Home","title":"InflationEvalTools.share_combination_weights_rmse","text":"share_combination_weights_rmse(tray_infl::AbstractArray{F,3}, tray_infl_param::AbstractArray{F,3}, λ::AbstractFloat = 0.0) -> Vector{F}\n\nCompute a vector of non-negative weights β that sum to 1 by minimizing a nonlinear loss function based on the average root mean squared error (RMSE).\n\nArguments:\n\ntray_infl::AbstractArray{F,3}: Simulated inflation trajectories.\ntray_infl_param::AbstractArray{F,3}: Parametric inflation trajectories.\nλ::AbstractFloat = 0.0: Regularization parameter to penalize small weights.\n\nSee also: share_combination_weights_absme\n\n\n\n\n\n","category":"function"},{"location":"#InflationEvalTools.share_combination_weights_absme","page":"Home","title":"InflationEvalTools.share_combination_weights_absme","text":"share_combination_weights_absme(tray_infl::AbstractArray{F,3}, tray_infl_param::AbstractArray{F,3}, λ::AbstractFloat = 0.0) -> Vector{F}\n\nCompute a vector of non-negative weights β that sum to 1 by minimizing a nonlinear loss function based on the absolute average mean error.\n\nArguments:\n\ntray_infl::AbstractArray{F,3}: Simulated inflation trajectories.\ntray_infl_param::AbstractArray{F,3}: Parametric inflation trajectories.\nλ::AbstractFloat = 0.0: Regularization parameter to penalize small weights.\n\nSee also: share_combination_weights_rmse\n\n\n\n\n\n","category":"function"}]
}
